{
  "time": 1711232666978,
  "blocks": [
    {
      "id": "-DikONHq7E",
      "type": "paragraph",
      "data": {
        "text": "Connecting a Laravel backend with the Vue frontend is straightforward. You just need to scaffold Vue via <a href=\"https://inertiajs.com\">Inertia</a>, which comes built-in with authentication and other cool stuff. If you don't want to use Inertia, installing Vue manually in a Laravel app is also too much easy. All your frontend stuff is kept in the resources/js directory. In short, implementing a Vue frontend is not a big deal when it comes to having a Laravel backend. But having to use Nuxt is another story. It's not that straightforward as a simple Vue SPA because the structure of a Nuxt app is a lot different than a normal Vue app due to a lot of reasons, one of which is <a href=\"https://vuejs.org/guide/scaling-up/ssr.html\">Server-Side Rendering (SSR)</a>. We basically need two different applications when using Nuxt with a Laravel backend to follow the <a href=\"https://en.wikipedia.org/wiki/Separation_of_concerns\">Separation of Concerns (SoC)</a> rule. This approach lets us easily manage both the frontend and the backend."
      }
    },
    {
      "id": "OOIkJmRfOL",
      "type": "header",
      "data": { "text": "Why do i want to write this article?", "level": 3 }
    },
    {
      "id": "uFlJ1Kl1BN",
      "type": "paragraph",
      "data": {
        "text": "When integrating my Nuxt frontend with the Laravel backend, I encountered numerous issues that took me days to resolve. I conducted extensive research and eventually succeeded in making it work. Consequently, I resolved to assist other developers experiencing similar challenges in this context. This article will guide you through the steps to integrate your Nuxt application with the Laravel backend."
      }
    },
    {
      "id": "qE8JqDnptp",
      "type": "header",
      "data": { "text": "Setting up the Laravel application", "level": 3 }
    },
    {
      "id": "zXCRqMyf2X",
      "type": "code",
      "data": { "code": "composer create-project laravel/laravel api" }
    },
    {
      "id": "dIsA3tZ9Hi",
      "type": "paragraph",
      "data": {
        "text": "Then, we will install <a href=\"https://github.com/laravel/breeze\">Laravel Breeze</a>, which will set up the entire authentication system in our application, including registration, login, logout, password reset, and email verification functionalities."
      }
    },
    {
      "id": "p9ZHtsdxrm",
      "type": "code",
      "data": { "code": "php artisan breeze:install" }
    },
    {
      "id": "VJvcTqLFpc",
      "type": "image",
      "data": {
        "file": {
          "url": "http://127.0.0.1:8000/storage/post_uploads/FTyRVVm7EmXjWqQBQT9npVOlFd0ZXFmKJA1i8nTD.png"
        },
        "caption": "A testing image",
        "withBorder": false,
        "stretched": false,
        "withBackground": false
      }
    },
    {
      "id": "4aKjf4tbyO",
      "type": "paragraph",
      "data": {
        "text": "You will be prompted to select the preferred breeze stack. Select <b>API only</b>. After that, select your preferred testing framework (we won't use testing here). Then set up the database in <b>.env</b> file."
      }
    },
    {
      "id": "YWyM_2bzlh",
      "type": "code",
      "data": {
        "code": "DB_CONNECTION=sqlite\nDB_HOST=127.0.0.1\nDB_PORT=3306"
      }
    },
    {
      "id": "jsqhyyZB8E",
      "type": "paragraph",
      "data": {
        "text": "We are using SQLite here (you can use your preferred one). Then run the migration to create tables."
      }
    },
    {
      "id": "gANlL017lh",
      "type": "code",
      "data": { "code": "php artisan migrate" }
    },
    {
      "id": "x3LH2jDq3P",
      "type": "paragraph",
      "data": {
        "text": "Take a look at <b>app\\Http\\Controllers\\Auth\\AuthenticatedSessionController</b>&nbsp;(which is given by Breeze):"
      }
    },
    {
      "id": "WoAV67AuYE",
      "type": "code",
      "data": {
        "code": "<?php\n\nnamespace App\\Http\\Controllers\\Auth;\n\nuse App\\Http\\Controllers\\Controller;\nuse App\\Http\\Requests\\Auth\\LoginRequest;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Http\\Response;\nuse Illuminate\\Support\\Facades\\Auth;\n\nclass AuthenticatedSessionController extends Controller\n{\n    /**\n     * Handle an incoming authentication request.\n     */\n    public function store(LoginRequest $request): Response\n    {\n        $request->authenticate();\n\n        $request->session()->regenerate();\n\n        return response()->noContent();\n    }\n\n    /**\n     * Destroy an authenticated session.\n     */\n    public function destroy(Request $request): Response\n    {\n        Auth::guard('web')->logout();\n\n        $request->session()->invalidate();\n\n        $request->session()->regenerateToken();\n\n        return response()->noContent();\n    }\n}"
      }
    },
    {
      "id": "SeWAc8V-RK",
      "type": "paragraph",
      "data": {
        "text": "When you send a request from your frontend to <i>http://localhost:8000/login</i>, the request will be handled by this controller's store method. Here, it takes the user's email/password, authenticates the user, and generates a user session on the server, setting cookies in the browser which are later used to authenticate users. Sending a request to the /logout route will log the user out by invalidating the session. While Breeze implements all the authentication-related routes and controllers, we will need to use <a href=\"https://larave.com/docs/sanctum\">Laravel Sanctum</a> to enable cookie-based authentication for our SPA. As the Laravel Sanctum documentation states:"
      }
    },
    {
      "id": "5V3YQDzYlw",
      "type": "paragraph",
      "data": {
        "text": "<i>\"Sanctum uses Laravel's built-in cookie based session authentication services. Typically, Sanctum utilizes Laravel's web authentication guard to accomplish this\"</i>"
      }
    },
    {
      "id": "4Vf1XstYMn",
      "type": "paragraph",
      "data": { "text": "This command will install sanctum and set it up." }
    },
    {
      "id": "gz8sNmkJ_e",
      "type": "code",
      "data": { "code": "php artisan api:install" }
    },
    {
      "id": "b7uVKCoG2d",
      "type": "paragraph",
      "data": {
        "text": "Lastly, configure <b>.env</b> to allow your frontend to send requests to your backend."
      }
    },
    {
      "id": "WYl8WOPNss",
      "type": "code",
      "data": {
        "code": "SANCTUM_STATEFUL_DOMAINS=\"localhost:8000,localhost:3000\"\nSESSION_DOMAIN=localhost"
      }
    },
    {
      "id": "S3J4_lCuu8",
      "type": "paragraph",
      "data": {
        "text": "Here we are setting <b>SANCTUM_STATEFUL_DOMAINS</b>&nbsp;in which the first one is the backend URL and the second one is the frontend URL. (Don't use protocot <i>http://</i>&nbsp;or <i>https://</i> here). <b>SESSION_DOMAIN</b> is the <a href=\"https://www.cloudflare.com/learning/dns/top-level-domain/#:~:text=What%20is%20a%20top%2Dlevel%20domain%20(TLD)%3F,.com'%20is%20the%20TLD.\">Top-Level Domain (TLD)</a> of the app which in this case is localhost.&nbsp;"
      }
    },
    {
      "id": "h5Ut_cxSMy",
      "type": "paragraph",
      "data": {
        "text": "<i><b>Note that for Sanctum authentication to function correctly with your Nuxt frontend, it is imperative that your frontend and backend share the same Top-Level Domain (TLD).</b></i>"
      }
    },
    {
      "id": "2p_9LZGzMx",
      "type": "header",
      "data": { "text": "Setting up the Nuxt frontend", "level": 3 }
    },
    {
      "id": "JqjjAwNPjl",
      "type": "paragraph",
      "data": { "text": "Create a starter Nuxt project." }
    },
    {
      "id": "V9f7suR1BM",
      "type": "code",
      "data": { "code": "npx nuxi@latest init client\ncd /client\nnpm install" }
    },
    {
      "id": "WkiP3sP4aG",
      "type": "paragraph",
      "data": {
        "text": "Then, we will install <a href=\"https://pinia.vuejs.org/\">Pinia</a> to handle state management."
      }
    },
    {
      "id": "Rfvf2XaOu1",
      "type": "code",
      "data": { "code": "npm install pinia @pinia/nuxt" }
    },
    {
      "id": "p-V-OcHP_w",
      "type": "paragraph",
      "data": {
        "text": "Add pinia to the modules section of nuxt config file."
      }
    },
    {
      "id": "T9-fJ8rPnZ",
      "type": "code",
      "data": {
        "code": "// nuxt.config.js\nexport default defineNuxtConfig({\n  // ... other options\n  modules: [\n    // ...\n    '@pinia/nuxt',\n  ],\n});"
      }
    },
    {
      "id": "KhGVabxnwN",
      "type": "paragraph",
      "data": {
        "text": "We will be utilizing <b>useFetch</b>&nbsp;and <b>$fetch</b>&nbsp;for data fetching. According to the Nuxt documentation:"
      }
    },
    {
      "id": "_OmGprS3gn",
      "type": "paragraph",
      "data": {
        "text": "◦<i>&nbsp;\"useFetch is the most straightforward way to handle data fetching in a component setup function\"</i>"
      }
    },
    {
      "id": "lr_quNCi9U",
      "type": "paragraph",
      "data": {
        "text": "◦<i>&nbsp;\"$fetch is great to make network requests based on user interaction.\"</i>"
      }
    },
    {
      "id": "_cGG5U1xsO",
      "type": "paragraph",
      "data": {
        "text": "But we won't need to set up these methods again and again for sending requests to our backend. Instead we will create two composables."
      }
    },
    {
      "id": "0VsyZ64HG5",
      "type": "paragraph",
      "data": { "text": "<i>composables/api.js</i>" }
    },
    {
      "id": "sDUM5vzrtE",
      "type": "code",
      "data": {
        "code": "export const $api = (url, options = {}, headers = {}) => {\n  const token = useCookie(\"XSRF-TOKEN\");\n\n  if (token.value) {\n    headers[\"X-XSRF-TOKEN\"] = token.value;\n  }\n\n  const apiFetch = $fetch.create({\n    baseURL: \"http://localhost:8000\",\n    headers: {\n      Accept: \"application/json\",\n      \"Content-Type\": \"application/json\",\n      ...headers,\n    },\n    credentials: \"include\",\n  });\n\n  return apiFetch(url, {\n    ...options,\n  });\n}"
      }
    },
    {
      "id": "S92xpZ7RT5",
      "type": "paragraph",
      "data": {
        "text": "This composable utilizes <b>$fetch</b> to send requests, configuring the base URL and additional headers within the composable. It also includes the attachment of the <a href=\"https://portswigger.net/web-security/csrf\">CSRF</a> Token (if available) to the headers, establishing trust between the Laravel backend and our frontend. This composable will be employed during user interactions, such as when a user submits the login form. Its primary purpose is to handle client-side requests that are visible in the browser's devtools Network Tab."
      }
    },
    {
      "id": "9CnfLCPX-M",
      "type": "paragraph",
      "data": { "text": "<i>composables/useApiFetch.js</i>" }
    },
    {
      "id": "jAXxxthlJh",
      "type": "code",
      "data": {
        "code": "export default function (url, options = {}) {\n  options.headers = {};\n\n  const token = useCookie(\"XSRF-TOKEN\");\n\n  if (token.value) {\n    options.headers[\"X-XSRF-TOKEN\"] = token.value;\n  }\n\n  return useFetch(\"http://localhost:8000\" + url, {\n    ...options,\n    credentials: \"include\",\n    headers: {\n      ...options.headers,\n      Accept: \"application/json\",\n      \"Content-Type\": \"application/json\",\n      ...useRequestHeaders([\"cookie\"]),\n      referer: \"http://localhost:3000\",\n    },\n  });\n}"
      }
    },
    {
      "id": "MKRrk3CfKh",
      "type": "paragraph",
      "data": {
        "text": "This composable is almost same as the above one but its primary goal is to send request on the server-side, that's why it attaches cookies along to the requests and also the referer header.&nbsp;"
      }
    },
    {
      "id": "EhXTqEC7tr",
      "type": "paragraph",
      "data": {
        "text": "Then, we will setup auth store in <b>stores/auth.js</b> to handle our auth states:"
      }
    },
    {
      "id": "Rjii0KlbNm",
      "type": "code",
      "data": {
        "code": "import { defineStore } from \"pinia\";\nimport { $api } from \"~/composables/api\";\n\nexport const useAuthStore = defineStore(\"auth\", () => {\n\n  const user = ref(null);\n  const loading = ref(true);\n\n  const isLoggedIn = computed(() => !!user.value);\n\n  async function attemptLogin(data) {\n    try {\n      await $api(`/sanctum/csrf-cookie`);\n\n      await $api(`/login`, {\n        body: data,\n        method: \"post\",\n      });\n\n      await useAuthStore().fetchUser();\n\n      return navigateTo(\"/\", { replace: true });\n    } catch (err) {\n    \t// handle errors\n    }\n  }\n\n  async function fetchUser() {\n    const { data, error } = await useApiFetch(\"/api/user\");\n\n    loading.value = false;\n\n    if (!error.value && data.value) {\n      user.value = data.value.data;\n    } \n  }\n\n  async function logout() {\n    try {\n      await $api(`/api/logout`, { method: \"post\" });\n\n      user.value = null;\n\n      return navigateTo(\"/login\", { replace: true });\n    } catch (err) {\n      // handle errors\n    }\n  }\n\n\n  return {\n    attemptLogin,\n    fetchUser,\n    logout,\n    user,\n    isLoggedIn,\n  };\n});"
      }
    },
    {
      "id": "AZUOo8T7T8",
      "type": "paragraph",
      "data": {
        "text": "Our store utilizes the <b>$api</b> and <b>useApiFetch</b> composables. The <b>attemptLogin</b> function is responsible for logging the user in, but it first sends a GET request to the /sanctum/csrf-cookie endpoint of our backend to set CSRF cookies on the browser. It's crucial to note that before sending requests to non-auth endpoints like <i>/login</i> or <i>/register</i>, we must first send a request to this endpoint, or else we will encounter the 419 CSRF token mismatch error."
      }
    },
    {
      "id": "01yS1grlV-",
      "type": "paragraph",
      "data": {
        "text": "Additionally, our store implements a <b>fetchUser</b> function, which loads the user using the useApiFetch composable. The reason for using useApiFetch here is to load the user on the server side, ensuring that when the page renders, the user is already loaded.The <b>logout</b> method is straightforward and requires no further explanation."
      }
    },
    {
      "id": "ghH1rxZ1tO",
      "type": "paragraph",
      "data": {
        "text": "Now, we will have a simple login form to trigger the <b>attemptLogin</b> function."
      }
    },
    {
      "id": "ZbpZ45Rh64",
      "type": "paragraph",
      "data": {
        "text": "<i>pages/login.vue</i>&nbsp;(In browser, visit <i>http://localhost:3000/login</i>)"
      }
    },
    {
      "id": "RnPPfJW2k1",
      "type": "code",
      "data": {
        "code": "<template>\n  <form @submit.prevent=\"handleSubmit\">\n    <label for=\"email\">Email:</label>\n    <input type=\"email\" id=\"email\" v-model=\"email\">\n    <label for=\"password\">Password:</label>\n    <input type=\"password\" id=\"password\" v-model=\"password\">\n    <button type=\"submit\">Login</button>\n  </form>\n</template>\n\n<script setup>\nconst auth = useAuthStore();\n\nconst email = ref('');\nconst password = ref('');\n\nconst handleSubmit = async () => {\n  await auth.attemptLogin({ email: email.value, password: password.value })\n\n  email.value = '';\n  password.value = '';\n};\n</script>"
      }
    },
    {
      "id": "Kfwaz6Uj4N",
      "type": "paragraph",
      "data": {
        "text": "And also the home page after successfull login we will redirect the user to:"
      }
    },
    {
      "id": "sk7hRINOKi",
      "type": "paragraph",
      "data": {
        "text": "<i>pages/index.vue</i> (In browser, visit <i>http://localhost:3000/</i>)"
      }
    },
    {
      "id": "kvmSSgUxui",
      "type": "code",
      "data": {
        "code": "<template>\n\t<div class=\"container\">\n\t\t<h1>Welcome {{ auth.user.name }}</h1>\n\t</div>\n</template>\n\n<script setup>\nconst auth = useAuthStore();\n</script>"
      }
    },
    {
      "id": "APSgdn5cl9",
      "type": "paragraph",
      "data": {
        "text": "Till now, the login functionality will work fine, but when we will refres the page, pinia will reset its store states resulting in the user state setting to null and isLoggedIn to false."
      }
    },
    {
      "id": "97rlhUPDf_",
      "type": "header",
      "data": { "text": "What's the solution?", "level": 3 }
    },
    {
      "id": "PoatH_w_rz",
      "type": "paragraph",
      "data": {
        "text": "To resolve this issue, we will create a plugin that will load the user on the server side. The plugin will first if the user state is null, then it will re-fetch the user. This will load the user on initial page load as well."
      }
    },
    {
      "id": "ztB20YZDYI",
      "type": "paragraph",
      "data": { "text": "<i>plugins/loadUser.js</i>" }
    },
    {
      "id": "tdV5EWkSl4",
      "type": "code",
      "data": {
        "code": "export default defineNuxtPlugin(async (nuxtApp) => {\n  const auth = useAuthStore();\n\n  if (!auth.isLoggedIn) {\n    await auth.fetchUser();\n  }\n});"
      }
    },
    {
      "id": "QKD6xVMbNX",
      "type": "header",
      "data": {
        "text": "Creating middleware for routes protection",
        "level": 3
      }
    },
    {
      "id": "z25ROdUFq4",
      "type": "paragraph",
      "data": {
        "text": "Now, we need to create middlewares to protect our routes from being accessed directly. The first auth middleware will prevent non-authenticated users from accessing the protected pages, while the second guest middleware will prevent authenticated users from accessing the <i>/login</i> and <i>/register</i> routes."
      }
    },
    {
      "id": "1oH1XmH3Zm",
      "type": "paragraph",
      "data": { "text": "<i>middleware/auth.js</i>" }
    },
    {
      "id": "ZY7WqV8qkS",
      "type": "code",
      "data": {
        "code": "export default defineNuxtRouteMiddleware((to, from) => {\n  const auth = useAuthStore();\n\n  if (!auth.isLoggedIn) {\n    return navigateTo(\"/login\", { replace: true });\n  }\n});"
      }
    },
    {
      "id": "pTUBFWV1Dq",
      "type": "paragraph",
      "data": { "text": "<i>middleware/guest.js</i>" }
    },
    {
      "id": "WhJ4RlOTwd",
      "type": "code",
      "data": {
        "code": "export default defineNuxtRouteMiddleware((to, from) => {\n  const auth = useAuthStore();\n\n  if (auth.isLoggedIn) {\n    return navigateTo(\"/\", { replace: true });\n  }\n});"
      }
    },
    {
      "id": "a_r_3aCxJN",
      "type": "paragraph",
      "data": {
        "text": "And no way to forget to add these middlewares to the respective pages. "
      }
    },
    {
      "id": "GVCDooRKXq",
      "type": "paragraph",
      "data": { "text": "To the <i>index.vue</i> (or other protected pages):" }
    },
    {
      "id": "_T-TO9gNxi",
      "type": "code",
      "data": {
        "code": "<script setup>\n// Other stuff\n\ndefinePageMeta({\n  middleware: [\"auth\"],\n});\n\n</script>"
      }
    },
    {
      "id": "TW9GFDPhqB",
      "type": "paragraph",
      "data": {
        "text": "To the <i>login.vue</i> (or other similar pages like <i>/register</i> etc):"
      }
    },
    {
      "id": "gLZgQ5_xDL",
      "type": "code",
      "data": {
        "code": "<script setup>\n// Other stuff\n\ndefinePageMeta({\n  middleware: [\"guest\"],\n});\n\n</script>"
      }
    },
    {
      "id": "YuJfyJwD3e",
      "type": "header",
      "data": { "text": "Conclusion", "level": 3 }
    },
    {
      "id": "gVnXCSpFke",
      "type": "paragraph",
      "data": {
        "text": "Following the guidelines outlined in the official documentation for Laravel's API authentication system, Sanctum and Breeze, makes integrating a Nuxt frontend with a Laravel backend straightforward. Just stick to these instructions, and you'll be ready to go without much trouble"
      }
    },
    {
      "id": "rnh__Pd01O",
      "type": "list",
      "data": {
        "style": "ordered",
        "items": [
          "This is the first item",
          "This is the second one",
          "Huuh, the third one&nbsp;",
          "No way the fourth one"
        ]
      }
    },

    {
      "id": "rnh__Pd0655",
      "type": "list",
      "data": {
        "style": "unordered",
        "items": [
          {
            "content": "Apples",
            "items": [
              {
                "content": "Red",
                "items": [
                  {
                    "content": "Foo",
                    "items": []
                  }
                ]
              },
              {
                "content": "Green",
                "items": []
              }
            ]
          },
          {
            "content": "Bananas",
            "items": [
              {
                "content": "Yellow",
                "items": []
              }
            ]
          }
        ]
      }
    },

    {
      "id": "rHeQGuKEZ9",
      "type": "paragraph",
      "data": { "text": "🚀 Happy Coding&nbsp;🙋" }
    },
    {
      "id": "yTfmwoOEc4",
      "type": "table",
      "data": {
        "content": [
          ["Kine", "1 pcs", "100$"],
          ["Dogs", "3 pcs", "200$"],
          ["Chickens", "12 pcs", "150$"],
          ["Cats", "15 pcs", "50$"]
        ]
      }
    },
    {
      "type": "quote",
      "data": {
        "text": "The only true wisdom is in knowing you know nothing. An unexamined life is not worth living. I cannot teach anybody anything. I can only make them think.",
        "caption": "Socrates",
        "alignment": "left"
      }
    },
    {
      "id": "SVgWCTVw0B",
      "type": "embed",
      "data": {
        "service": "github",
        "source": "https://gist.github.com/MUHAMMADSiyab/d23f033304b459faa9c35e7e8d61ea30",
        "embed": "data:text/html;charset=utf-8,<head><base target=\"_blank\" /></head><body><script src=\"https://gist.github.com/MUHAMMADSiyab/d23f033304b459faa9c35e7e8d61ea30.js\" ></script></body>",
        "width": 600,
        "height": 300,
        "caption": "Amazing gist&nbsp;"
      }
    },
    {
      "id": "-M1RjHw1ym",
      "type": "embed",
      "data": {
        "service": "youtube",
        "source": "https://youtu.be/o8B0RCmJRWI",
        "embed": "https://www.youtube.com/embed/o8B0RCmJRWI",
        "width": 580,
        "height": 320,
        "caption": ""
      }
    },
    {
      "id": "Xwg08jiprx",
      "type": "embed",
      "data": {
        "service": "instagram",
        "source": "https://www.instagram.com/p/C4nr9JVM2of/?utm_source=ig_web_copy_link",
        "embed": "https://www.instagram.com/p/C4nr9JVM2of/embed",
        "width": 400,
        "height": 505,
        "caption": "WOW Engin looks smart"
      }
    },
    {
      "id": "dEbESVPCqW",
      "type": "embed",
      "data": {
        "service": "facebook",
        "source": "https://www.facebook.com/icc/posts/pfbid026PLtyDi1CXPX3B9ZVVnkJqmew4f1QwDX5JCm2BtzQY7zYZ6D3GMmRnBx9A68vR9yl",
        "embed": "https://www.facebook.com/plugins/post.php?href=https://www.facebook.com/icc/posts/pfbid026PLtyDi1CXPX3B9ZVVnkJqmew4f1QwDX5JCm2BtzQY7zYZ6D3GMmRnBx9A68vR9yl&width=500",
        "caption": "ICC is playing games"
      }
    },
    {
      "id": "tnAk5pI18J",
      "type": "embed",
      "data": {
        "service": "codepen",
        "source": "https://codepen.io/aryan-michael-jordan/pen/RwoMbvR",
        "embed": "https://codepen.io/aryan-michael-jordan/embed/RwoMbvR?height=300&theme-id=0&default-tab=css,result&embed-version=2",
        "width": 600,
        "height": 300,
        "caption": "Amazing and mind blowing animation"
      }
    }
  ],
  "version": "2.29.0"
}
